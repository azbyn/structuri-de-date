\documentclass[11pt,a4paper]{article}
\usepackage{indentfirst}
\usepackage{minted} %must be installed
\usepackage{mathtools} % misc math
\usepackage{ulem}
\usepackage{caption}
\DeclareRobustCommand{\hsout}[1]{\texorpdfstring{\sout{#1}}{#1}}
\usepackage{amssymb} % math symbols
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{enumitem} % for [leftmargin=*]
\usepackage{geometry} % for better controll of margins

\usepackage[romanian]{babel} %romanian names

\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=cyan, citecolor=green, filecolor=black, urlcolor=blue}
\newmintinline[code]{cpp}{}
\newmintinline[inst]{nasm}{}
\newmintinline[bashi]{bash}{}

\geometry{a4paper,left=25mm,right=20mm,top=25mm,bottom=25mm}

\newminted[cpp]{cpp} {
  linenos,
  frame=single,
  %breaklines,
  %style=vs,
  fontsize=\large,
  escapeinside=@@
}

\newminted[asm]{nasm} {
  linenos,
  frame=single,
  %breaklines,
  %style=vs,
  fontsize=\large,
  escapeinside=@@
}

\newminted[bash]{bash} {
  linenos,
  frame=single,
  %breaklines,
  %style=vs,
  fontsize=\large,
  escapeinside=@@
}
\newminted[py]{python} {
  linenos,
  frame=single,
  %breaklines,
  %style=vs,
  fontsize=\large,
  escapeinside=@@
}

\usepackage{xparse}

\newcommand{\mat}[1]{\mathcal{M}_{#1}(\mathbb{R})}
\newcommand{\matmn}{\mat{m\times{}n}}
\newcommand{\matn}{\mat{n}}

%\usepackage{tocloft}
%\usepackage{tipa}

\title{Cum să treci la Moro\footnote{Probabil} \\ - \large{explicat prost de Pavel} -}
\date{}
\author{}
\begin{document}
\maketitle

\tableofcontents
\vspace{1em}
Acest document este făcut în mare parte pentru scopuri de divertisment.

Până și în curs apare ,,cmoro'' - pag 8 (sau 152) - cap5.pdf

\section{Introducere}
\begin{center}
  Sistemul de calcul = Componenta Hardware + Componenta Software + Sistem de intreruperi
\end{center}

Sistem de calcul: Chestie care face calcule - nume pedantic pentru calculator.

Componenta Hardware: micro procesor, memorie, busuri, module IO\footnote{Intrare ieșire} etc.

Componenta Software: Aplicație Sistem de operare, alte aplicații.

Componenta Hardware fara Sistem de operare = caramidă care nu face nimic.

\href{https://en.wikipedia.org/wiki/Interrupt}{Sistem de intreruperi}: pe scurt legatura dintre hardware și software

Moduri de operare pentru aplicații:

\quad\quad text - MS-DOS, Linux
  
\quad\quad grafic - Windows, Linux

- Linux le face pe amândouă, deci e mai bun dăă - Profu'

Memoria poate fi

\quad \quad principală: RAM (Random Access Memory), ROM (Read Only Memory)  - rapida dar nevolatilă in cazul RAM (moare daca moare si curentu)

\quad \quad secundara: HDD (Hard Disk Drive) - lentă dar volatilă (nu moare decat dacă bagi burghiul în ea)

Din \href{https://www.quora.com/Why-does-8086-use-segmentation}{motive istorice} procesorul Intel 8086 (pentru care a fost ințial creat DOS) împarte memoria în segmente calculând adresele astfel (și profu vrea să știm asta):
\begin{center}
  Adresa fizica = Adresa segment $\cdot$ 16 + Adresă Efectivă
\end{center}

\section{Procesorul}
Elementul principal al unui Sistem de calcul este Procesorul:

Procesor - bucata de silicon (și altele) care care transforma numere binare în instrucțiuni executate\footnote{La fel ca Cuzzi și Pavel care transformă băuturi nespecificate italiene (care nici macar nu sunt facute in Italia) în cod LaTeX}.

Procesorul e format din:

\quad\quad \textbf{UC} (Unitate de control) - chestia care determina ce instrucțiuni sa execute procesorul

\quad\quad \textbf{UAL} (Unitate aritmetica și logică) - chestia care calculeaza

\quad\quad \textbf{Registrii} - chestii pentru stocarea rezultatelor imediate - mai rapide decat RAM - importante în limbajul de asamblare 

\subsection*{Cum facem \hsout{calculatorul} sistemul de calcul să facă ce vrem}

Procesorul înțelege limbaj mașină care este interpretat ca instrucțiuni care arată cam așa:
\begin{verbatim}
6E6F7468696E6720746F20736565206865726500B241B402CD21
\end{verbatim}

Pentru că este greu de ințeles pentru oameni, a fost creat Limbajul de asamblare, care este puțin mai rezonabil:
\begin{asm}
mov dl, 'A'
mov ah, 2
int 21h
\end{asm}

Acest ,,Limbaj de asamblare'' transformat în limbaj mașină de către un asamblor (cum ar fi TASM pentru DOS).
\\

Mai există și alte limbaje de programare, cum ar fi C++, care sunt transformate in limbaj de asamblare (si apoi in limbaj masina) dar ăsta nu-i important pt profu.

\subsection*{Interpretoare}


In loc sa transformăm un limbaj în altul mai ,,aproape de mașină'', putem rula într-un interpretor:

Interpretor: program care face pașii facuți de un microprocesor (fetch - decode -execute), dar în software, nu hardware.

Un avantaj e că instructiunile intelese de interpretor pot fi mai simple.
Alt avantaj ar fi că putem rula același program pe mai multe arhitecturi fară a-l compila (lucru care poate dura \textbf{mult} timp\footnote{vreo 3 ore pe un procesor normal pentru \href{http://clang.llvm.org/}{clang}}).

De exemplu javascript (ăla care face sa apara 12 reclame la 2 secunde după ce intri pe un site) este rulat într-un interpretor.

\section{Limbaj de asamblare}
\subsection*{Cum asamblam}
Pe DOS\footnote{că e mai simplu - dăă} exista un program debug care ne permite să ,,depanăm'' executabile\footnote{pe scurt - să vedem de ce nu merg}.
În Debug putem (deși e foarte limitat) crea programe in limbaj de asamblare.

Tot în DOS\footnote{heh} putem folosi TASM pentru a converti un fișier .asm într-unul .com, care poate fi rulat de DOS.

\subsection*{Cum arată}
Pe scurt limbajul de asamblare e format din instrucțiuni simple\footnote{except for when they arent} cu nume scurte\footnote{ahem, VFNMSUBSD} care sunt de forma:
\begin{asm}
  label: memonic [argument[, argument]]
\end{asm}

Printre cele mai importate instructiuni se numără:

\quad \quad \inst{mov a, b} - ,,mută'' conținutul din b în a

\quad \quad \inst{add a, b}, \inst{sub a, b} - echivalentul în cpp pt \code{a += b;}, respectiv \code{a -= b;}

\quad \quad \inst{cmp a, b} - compara pe a cu b, modificand registrul ,,flags'', urmat de obicei de: 

\quad \quad \inst{jl label}, \inst{jle}, \inst{jg}, \inst{je}, \ldots - procesorul ,,sare'' execuția daca în comparația precedentă a < b, resp a $\le$  b, a > b, a = b, \ldots

\quad \quad \inst{int numar} - invoca o ,,întrerupere'' - pe scurt apelam sistemul de operare, de exemplu pentru a afișa ceva pe ecran. DOS se folosește des \href{http://spike.scu.edu.au/~barry/interrupts.html}{\inst{int 21h}}.

\section{Linux}
Cum instalăm Linux: are profu vreo 35\footnote{da, 35} de documente care explica cum sa instalam Linux.

\subsection*{Lucrul în BASH}
Daca deschidem un terminal\footnote{Butonul ăla rotund din stânga-sus
  (stânga aia: $\leftarrow$), cauți ,,Terminal'', sau \texttt{Ctrl+Alt+T}}
suntem întămpinați de un prompter (chestie care așteaptă comenzi de la tine) care arata cam așa:
\begin{verbatim}
cmoro@syst-calcul: ~$
\end{verbatim}

Sub Linux, deoarece \textbf{totul} este un fișier (inclusiv outputul si inputul comenzilor) putem face asta:
\begin{itemize}
\item redirecționarea outputului:
\begin{bash}
comandă > fișier
#de exemplu
ls > f 
\end{bash}
tot outputul comenzii este pus in fișierul menționat, conținutul vechi al fișierului (daca există) fiind suprascris.
\item concatenarea outputului redirecționat:
\begin{bash}
comandă >> fișier
#de exemplu
ls >> f 
\end{bash}
la fel ca mai sus, dar conținutul vechi este păstrat, outputul fiind concatentat.
\item redirecționarea inputului
\begin{bash}
comandă < fișier
#de exemplu
cat < f 
\end{bash}
fișierul f este folosit drept input pentru comandă - de obicei exista opțiuni mai bune.

\item pipe\footnote{nu am găsit o denumire bună în română}
\begin{bash}
cmd1 | cmd2
#de exemplu
ls | head
\end{bash}

outputul comenzii 1 este folosit ca input pentru comanda 2 - mai folositor decât pare.

\item \href{https://unix.stackexchange.com/questions/48392/understanding-backtick}{command substitution}
\begin{bash}
bla `comanda`
#de exemplu
ls `echo '/'`
#este inlocuit cu
ls /
\end{bash}
tot ce este între \bashi{``} este evaluat separat și apoi inlocuit in comanda.
Pentru că \bashi{echo '/'} are outputul ,,\texttt{/}'', ,,\texttt{/}'' este inlocuit in comandă
\item rularea in background
\begin{bash}
comandă&
#de exemplu
sleep 10&
\end{bash}
\item home
\begin{bash}
~
#de exemplu
ls ~/Desktop
\end{bash}
Un nume mai scurt pentru \texttt{/home/}\textit{numele tău aici}\texttt{/}
\end{itemize}

\subsection*{Comenzi}
In acest prompter putem introduce comenzi cum ar fi:

\quad \quad \texttt{cd dir} - schimbă directorul\footnote{aka folder} curent.

\quad \quad \texttt{pwd} - afișează directorul curent - destul de nefolositor că-ți arată deja BASHul unde ești.

\quad \quad \texttt{ls dir} - afișează conținutul directorului.

\quad \quad \texttt{mkdir dir} - face un director

\quad \quad \texttt{cp src dst} - îl copiaza pe src în dst

\quad \quad \texttt{mv src dst} - îl mută pe src în dst

\quad \quad \texttt{rm file} - șterge fișierul; \texttt{rm -r dir} pentru directoare

\quad \quad \texttt{ln -s src dst} - crează un link simbolic\footnote{un fel de shortcut} catre src. este indicat să folosim căi de acces complete
(aka \texttt{~/Desktop/f.txt}, nu \texttt{f.txt})

\quad \quad \texttt{cat f1 f2 ...} - concatenează conținutul fișierelor - folosit cel mai des doar pentru a afișa conținutul unui fișierelor

\quad \quad \texttt{tee f1} - afișa doar conținutul unui fișier

\quad \quad \texttt{pr, fmt, lp} - nefolositor din 2005 încoace

\quad \quad \texttt{wc f1} - afișează cate linii, cuvinte și câți biți sunt in fișier

\quad \quad \texttt{diff f1 f2} - afisează diferentele dintre cele 2 fișiere

\quad \quad \texttt{sort f1} - sortează liniile fisierului, dăă :))

\quad \quad \texttt{cut f1} - selectează coloane din fișiere

\quad \quad \texttt{paste f1, f2, ...} - pune pe fiecare linie continuturile fisierelor f1 ..., separate printr-un tab

\quad \quad \texttt{head f1 -n} - selectează primele n linii din fisier

\quad \quad \texttt{tail f1 -n} - selectează ultimele n linii din fisier


\quad \quad \texttt{chmod +x f1} - face fișierul f1 executabil

\subsection*{Now what?}

Dacă nu știți ce face o comanda, scriț\footnote{moro - 2020} in prompter
\begin{bash}
man comanda
#sau
comanda --help
\end{bash}

Daca se blocheaza o comanda (bucla infinita sau ceva) apasați \texttt{ctrl-c}

\subsection*{Editare text}
Din terminal putem folosi editorul \texttt{nano} (din care ieșim cu \texttt{ctrl+x}), sau \texttt{gedit} pentru un editor grafic:
\begin{bash}
nano fisier
#sau
gedit fisier&
\end{bash}

Sau cu redirecționarea outputului:
\begin{bash}
echo "Ana are mere" > fisier
\end{bash}

Mai putem deschide fisierul și cu dublu click ca oamenii plictisitori.

\subsection*{Scripturi\footnote{nu, nu din alea} și alte executabile}
În Linux putem crea scripturi\footnote{comenzi BASH puse într-un fișier astfel:}
\begin{bash}
echo "Bla bla comenzi..." > f.sh
bash f.sh
\end{bash}

Sau putem face fișierul executabil:

\begin{bash}
echo "#!/bin/bash
  Bla bla comenzi...
  " > f1
chmod +x f1
  
./f1
\end{bash}

Pentru a crea executabile putem folosi și C++:
\begin{bash}
echo "#include <iostream>
  Bla bla c++
  " > f.cpp
  
g++ f.cpp -o executabil
  
./executabil
\end{bash}

\subsection*{Numere de la 1 la 100\footnote{inlocuiți 100 cu cat va trebuie} intr-un fișier}
\begin{bash}
echo '
for i in {1..100}; do
  echo "$i"
done' > f.sh
bash f.sh > fisier

#sau: (va trebuie un fisier gol)
for i in {1..100}; do
  echo $i >> fisier
done
\end{bash}

\section{Întrebari existențiale ale lu' Moro}

Î: Ce fel de probleme sunt rezolvabile cu calculatorul\footnote{nu-l citați cu asta}?

R: Toate\footnote{inafara de unele chestii teoretice cum ar fi
  \href{https://en.wikipedia.org/wiki/Halting_problem}{The Halting Problem}} - daca nu acu, atunci in viitor - deși pot lua mult timp.
\\

Î: Ați instalat SO\footnote{a se citi Sî O} Linux?

R: Da. Tre să știe el tot?
\\

Î: Cum putem crea procese în SO Linux?

R: În mai multe feluri\footnote{Mai exact din modul grafic, in C/C++ cu \code{fork}, \code{execl} și prietenii, în BASH unde pot fii în background sau nu}.
\\

Î: Ce face comanda x (îți da ceva complicat cu multe argumente)?

R: Intri pe \href{https://explainshell.com}{explainshell.com} și-ți zîce
\newpage

Î: How it feels to use Linux

R: 


\begin{figure}[!hbt]
  \captionsetup{labelformat=empty}
\includegraphics[width=\linewidth]{kars.jpg}
\end{figure}
\end{document}
questions

